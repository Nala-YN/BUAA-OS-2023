alloc(n,align,clear) 返回alloc_mem的地址，其中alloc_mem-freemem是我们拥有的地址空间 n:要分配的字节数 align：内存对齐单位，一般为BY2PG clear：是否将内容清0
u_long page2kva(struct Page *pp) {
	return KADDR(page2pa(pp));
}
u_long page2pa(struct Page *pp) {
	return page2ppn(pp) << PGSHIFT;
}
u_long page2ppn(struct Page *pp) {
	return pp - pages;
}
struct Page *pa2page(u_long pa) 
u_long va2pa(Pde *pgdir, u_long va) 
KADDR(pa)
PADDR(kva) 
Memory size: 65536 KiB, number of pages: 16384
LIST_EMPTY(&(page_free_list)) //判断链表是否为空
LIST_FIRST(&(page_free_list)) //取第一个链表元素
LIST_REMOVE(pp, pp_link) //去除pp链表元素
LIST_NEXT(p, pp_link)
LIST_INSERT_HEAD(&(page_free_list),pp,pp_link);
memset((void*)page2kva(pp),0,BY2PG) //memset用的是虚拟地址
void page_free(struct Page *pp) 不清空物理页，只是将他插入free的链表，相应物理地址的内容不变
page_alloc(struct Page **new) //传入&pp，若成功分配则返回0，分配时会清空物理页
PDX(va) //由虚拟地址得到页目录项的相对地址，加上页目录地址可得页目录项地址
页目录项存储的是页表的物理地址，要用page2pa(pp)
*ppte=(Pte*)(KADDR(PTE_ADDR(*pgdir_entryp)))
PTE_ADDR(pte) 获取pte的前20位，后12置0
int pgdir_walk(Pde *pgdir, u_long va, int create, Pte **ppte) 传入页目录地址，要查找的虚拟地址，查找失败时是否创建，以及用来返回页表项的指针。
struct Page *page_lookup(Pde *pgdir, u_long va, Pte **ppte)在调用pgdir_walk的基础上获得物理页地址，同时和walk一样得到pte项地址
tlb_invalidate(asid, va);根据进程的asid与va使得TLB的对应失效
int page_insert(Pde *pgdir, u_int asid, struct Page *pp, u_long va, u_int perm)
struct Page {
    Page_LIST_entry_t pp_link; /* free list link */
    u_short pp_ref;
};
:set nonu :set nu
#define LIST_FOREACH(var, head, field)                                                             \
    for ((var) = LIST_FIRST((head)); (var); (var) = LIST_NEXT((var), field))
r,0 epc
make objdump
*pgdir_entryp=(page2pa(pp))|PTE_V|PTE_D;



LIST_INIT(env_free_list);
TAILQ_INIT(env_sched_list); //TAILQ相比LIST的不同在于头结点不仅有指向下一个结点的指针，还有指向链表尾结点的指针
LIST_HEAD(Env_list, Env);
TAILQ_HEAD(Env_sched_list, Env);
ENVX(envid) ((envid) & (NENV - 1)) 获取下10位？？
#define try(expr)                                                                                  \
	do {                                                                                       \
		int r = (expr);                                                                    \
		if (r != 0)                                                                        \
			return r;                                                                  \
	} while (0)
UVPT user virtual page table
UTOP<UVPT //UTOP以上由内核管理
int env_setup_vm(struct Env *e) //为进程控制块分配虚拟内存
int env_alloc(struct Env **new, u_int parent_id)
void load_icode(struct Env *e, const void *binary, size_t size)
void env_pop_tf(struct Trapframe *tf, u_int asid) //恢复现场，跳转到之前的程序位置
TAILQ_EMPTY(head)
TAILQ_NEXT(elm, field)
TAILQ_FIRST(head)
TAILQ_REMOVE(head, elm, field)